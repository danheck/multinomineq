% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count_binomial.R
\name{count_binomial}
\alias{count_binomial}
\title{Number of Product-Binomial Prior/Posterior Samples in Polytope}
\usage{
count_binomial(A, b, k = 0, n = 0, prior = c(1, 1), M = 10000, steps,
  batch = 10000)
}
\arguments{
\item{A}{a matrix with one row for each linear inequality constraint and one
column for each of the binomial parameters. The parameter space is defined
as all probabilities \code{x} that fulfill the order constraints  \code{A*x <= b}.}

\item{b}{a vector of the same length as the number of rows of \code{A}}

\item{k}{the number of Option B choices.
The default \code{k=0} an \code{n=0} is equivalent to sampling from the prior.}

\item{n}{the number of choices per item type.}

\item{prior}{a vector with two positive numbers defining the shape parameters of the beta prior distributions for each binomial rate parameter}

\item{M}{number of posterior samples drawn from the encompassing model}

\item{steps}{integer vector that indicates at which rows the matrix \code{A} is split for a stepwise computation of the Bayes factor (see details). In this case, \code{M} can be a vector with the number of samples drawn in each step from the (partially) order-constrained models using Gibbs sampling}

\item{batch}{size of the batches into which computations are split to reduce memory load}
}
\value{
a list with the elements
\itemize{
    \item\code{integral}: estimated probability that samples are in polytope
    \item\code{count}: number of samples in polytope
    \item\code{M}: total number of samples
}
}
\description{
Counts the number of prior/posterior samples for product-binomial data  that fall into
the polytope defined via A*x <= b. Useful to compute the encompassing Bayes factor.
}
\details{
The stepwise computation of the Bayes factor proceeds as follows:
If the steps are defined as \code{steps=c(5,10)}, the BF is computed in three steps by comparing:
(1) Unconstrained model vs. inequalities in \code{A[1:5,]};
(2) use posterior based on inequalities in \code{A[1:5,]} and check inequalities \code{A[6:10,]};
(3) sample from A[1:10,] and check inequalities in \code{A[11:nrow(A),]} (i.e., all inequalities).
}
\examples{
# linear order constraint:
# x1 < x2 < .... < x6 < .50
A <- matrix(c(1, -1, 0, 0, 0, 0,
              0, 1, -1, 0, 0, 0,
              0, 0, 1, -1, 0, 0,
              0, 0, 0, 1, -1, 0,
              0, 0, 0, 0, 1, -1,
              0, 0, 0, 0, 0, 1),
            ncol = 6, byrow = TRUE)
b <- c(0, 0, 0, 0, 0, .50)

k <- c(0, 3, 2, 5, 3, 7)
n <- rep(10, 6)

# check whether specific vector is in polytope:
A \%*\% c(.05, .1, .12, .16, .19, .23) <= b

# count prior samples and compare to analytical result
prior <- count_binomial(A, b, M = 5e5)
prior
(.50)^6 / factorial(6)

# count posterior samples and get Bayes factor
posterior <- count_binomial(A, b, k, n,
                            M=c(1e5, 2e4), steps = 2)
posterior$integral / prior$integral  # BF for constraints
count_to_bf(posterior, prior)
}
\references{
Hoijtink, H. (2011). Informative Hypotheses: Theory and Practice for Behavioral and Social Scientists. Boca Raton, FL: Chapman & Hall/CRC.
}
